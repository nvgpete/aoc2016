Moving in a room with lots of desks blocking your path.

The desks are places based on a function quadratic in X and Y with a
constant added to it. The constant (1358 in my case) is provided on the web
page so there is no d13a.txt file. The only interesting thing is that the
final decision on whether to place a desk is based on whether the
binary value of the result has an even or odd number of 1's.

There are lots of ways to write population counts in c, but since the newer
x86 chips have a popcount instruction, I figured I might as well use that.
Since there isn't any c operation that looks like a popcount, we use
__builtin_popcount(x), which will generate the proper assembly instruction.

We also have to a compiler optionsso that the compiler knows the instruction
is available, like
clang/gcc -march=native -O2 -Wall -o d13a d13a.c

The c code looks like 
return __builtin_popcount(<ugly_function>) & 1;
to see if the count is even or odd.

I dumped the assembly code with -S to see if I was actually getting the
popcount instruction, and sure enough

(some assembly to put ugly_function result in eax)
popcntl %eax, %eax
andl    $1, %eax

just as I hoped.

I also got the form of the -march=native wrong at first, and the code
generated by that was

(some assembly to put ugly_function result in eax)
movl   %eax, %ecx   // mov eax -> ecx
shrl   $16, %ecx    // shift high 16 bits to low 16 bits of ecx
xorl   %eax, %ecx   // xor ecx with eax, only care about low 16 bits
xorl   %eax, %eax   // clear eax
xorb   %ch, %cl     // xor the two bytes of the low half of ecx
setnp  %al          // set al low bit based on parity of previous result

which is really not much more than the popcnt. Smart compiler to realize I
didn't really need to do a popcnt, only a parity check.

To see the desk arrangement, compile with -DSHOW.

